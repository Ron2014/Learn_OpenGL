## 专业术语中英对照

- 标准化设备坐标(Normalized Device Coordinate, NDC)

空间分类

- 局部空间(Local Space，或者称为物体空间(Object Space))
- 世界空间(World Space)
- 观察空间(View Space，或者称为视觉空间(Eye Space), 摄像机空间(Camera Space))
- 裁剪空间(Clip Space)
- 屏幕空间(Screen Space)

变换矩阵分类

- 模型矩阵(Model Matrix)
- 观察矩阵(View Matrix)
- 投影矩阵(Projection Matrix)
- 视口变换(Viewport Transform)

坐标分类 - 与空间有对应关系

- 局部坐标(Local Coordinate)
- 世界坐标(World Coordinate)
- 观察坐标(View Coordinate)
- 裁剪坐标(Clip Coordinate)
- 屏幕坐标(Screen Coordinate)

变换流程

```flow
local=>start: 局部坐标
world=>subroutine: 世界坐标
view=>subroutine: 观察坐标
clip=>subroutine: 裁剪坐标
screen=>subroutine: 屏幕坐标

model_matrix=>operation: 模型矩阵
view_matrix=>operation: 观察矩阵
projection_matrix=>operation: 投影矩阵
viewport_transform=>operation: 视口变换

local->model_matrix->world->view_matrix->view->projection_matrix->clip->viewport_transform->screen->e

```

## 局部空间

与建模有关, 对象最开始所在的地方, 矩阵变换最开始的地方.

## 世界空间

目的: 将物体分散在世界排放. 

通过模型矩阵换算局部坐标. 感觉有点像是GameObject的Transform.

这个模型改变的是物体局部坐标系(只要说是坐标系, 中心点是固定的), 所以缩放/位移两个操作调换顺序之后, 结果不太一样.

推荐的做法是物体还在(0,0,0)点时先进行缩放, 然后再位移指定距离.

如果反过来, 先位移的距离也会被缩放.

缩放矩阵对一个(局部)坐标系(空间)进行变换, 看上去会像是挤压或者拉伸密封的盒子, 盒子里的(唯一)物体也跟着变换大小.

## 观察空间

与摄像机/相机/镜头的位置(Position)和朝向(Rotation)有关. 

摄像机应该仅有这两个属性, 对其缩放是没有意义的, 在Unity中就是这样.

观察矩阵(View Matrix) 也应该和这两个属性有关系.

它会根据这些, 将物体在世界空间的坐标转换为相机(作为第一人称视角)的空间的坐标.

似乎还有Fiew of View这个概念, 用来确定相机能看到的景深.

观察矩阵和世界坐标系有相对关系:

```
将摄像机向后移动，和将整个场景向前移动是一样的。
```

## 裁剪空间

观察空间 -> 裁剪空间变换过来经历了投影计算. 投影计算实际上是一种降维计算. 它统计的是3D向量在某个平面上的分量.

所以这个空间应该是个2D的了.

```
为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。
```

不知道这个范围是不是我们常说的FOV. (确切得来说也不算是, FOV是个角度, 这里的1000应该指的是后面提到得Far Plane的距离)

![Unity中的FOV](https://raw.githubusercontent.com/Ron2014/Ron2014.github.io/master/assets/images/fov.gif)

```
投影矩阵会将这个范围的坐标标准化到[-1.0, 1.0]空间, 范围外的坐标会被裁剪掉. 
```

听上去很像是投影矩阵同时完成了裁剪的工作. 

由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。

平截头体 Frustum，也就是常说的“视锥”。

都是箱子了, 应该算是裁剪了吧. 视锥是否和它有关系呢.

一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。

在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。

将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。

## 正射投影/正交投影 Orthographic Projection Matrix

正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。

这个创建的就是Unity的等距视图(isometric view), 没有透视效果, scene gizmo 切换到 Iso 模式可以看到.

正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视(Perspective)考虑进去。

这或许就是2D游戏的投影方法. 正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。

在GLM中可以这样创建一个透视投影矩阵：

```c
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
```

前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。

## 透视投影 Perspective Projection Matrix

正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：

顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。在GLM中可以这样创建一个透视投影矩阵：

```c
glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);
```

它的第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。可以看到, 这个值其实是个角度值, 观察Unity中设置的范围, 确实也是落在[0-180]这个区间. 正常大小一般都是45°, 末日风格(doom-style) 会大一些. 这里要解释一下为什么改变FOV, 从镜头内容来看会有一种拉近/推远相机(或者物体被放大缩小)的感觉. 那是因为视锥角度的改变, 导致视窗类绘制的坐标信息量产生增减造成的结果. 类似于聚光灯(spotlight), 照射到的内容就是我们看到的内容. 如果这个范围很大, 里面物体的(相对于该范围)的大小就变小, 反之亦然. 注意, **我们在相机内部看到的物体大小都是相对于视野的大小**, 这个概念似乎和观察空间相关.

第二个参数设置了宽高比，由视口的宽除以高所得。Unity中会有Viewport的W/H设置, 只是这两个值的范围都是[0.0,1.0]范围才有作用. 改变两个值, 你可以得手机的竖屏屏幕, 或者电影大片式的超宽横屏之类的体验.

第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设为100.0f。

## 把它们组合起来, 都是顶点着色器前面的工作

我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：

注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。

顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。

## OpenGL是右手坐标系

惊呆了我. 但是使用OpenGL的Unity却是左手坐标系.

## 投影矩阵及推导过程

<3D数学基础: 图形与游戏开发> 
  - 8.4 正交投影 
  - 9.3 正交矩阵 
  - 9.4.4 透视投影
[投影矩阵及推导过程](http://www.songho.ca/opengl/gl_projectionmatrix.html)

## Z缓冲 Z-Buffer

存储深度信息的地方，深度缓冲（Depth Buffer）。

深度值存在每个片段里。

深度测试 - Depth Testing， 由OpenGL自动完成。我们要告诉OpenGL我们想要启用深度测试；它默认是关闭的。

