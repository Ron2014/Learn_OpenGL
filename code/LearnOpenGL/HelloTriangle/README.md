## 渲染管线

渲染管线大致可以分为两大部分, 在这个过程中, 数据依次以四种形态存在:

1. 顶点: 坐标、颜色、法线、纹理坐标和边界标志 ----|---- 1. 3D坐标 -> 2D坐标
2. 图元(集合): 点 线段 多边形 ------------------|
3. 片段: 点及其相关信息 ------------------------|---- 2. 2D坐标 -> 屏幕像素
4. 像素----------------------------------------|

光栅化, 是这两大过程的分界点

OpenGL 命令流程大致分为:

1. 显示列表. 命令的缓存
2. 矩阵变换. 模式取景矩阵 + 投影矩阵 ---|---- 求值器 
3. 光照和颜色. 光照环境                |
4. 生成纹理坐标. 纹理矩阵 -------------|
- <顶点着色器>
5. 图元集. ===============================
6. 顶点数组. 图元装配
7. 图元.
8. 遮罩剔除. 投影矩阵 视体剪切
9. 转换成窗口坐标. 先标准化向量
- <几何着色器>
10. 光栅化. 将图元转换成2D图像 =====================
- <片段着色器>
11. Alpha 测试与混合
12. 帧缓冲区

## 顶点输入

顶点数据需要在GPU开辟存储空间, 称之为顶点缓冲区(Vertex Buffer). 管理这块缓冲区的对象叫顶点缓冲对象(Vertex Buffer Objects, VBO). 这种缓冲类型在OpenGL中定义为GL_ARRAY_BUFFER. 执行流程为:

1. 初始化一个缓冲对象, 拿到标识符(就像open文件拿到fd那样). glGenBuffers
2. 指定该对象代表顶点缓冲这个类型. glBindBuffer
3. 将顶点数据拷贝至该存储区. glBufferData

这样, 顶点数据都存储在显存中了.

## 顶点属性

顶点属性 -> 顶点着色器 -> gl_Position

顶点着色器中会指定顶点属性的序号, 这就要求我们必须手动指定输入数据的什么位置对应的顶点着色器的哪个顶点属性, 即: `顶点数据的解析`.

glVertexAttribPointer 参数:

1. 顶点属性序号. 与顶点着色器中 layout(location = XXX) 的XXX对应.
2. 顶点属性大小. 也就是变量的数量. 如果是vec3, 大小就是3.
3. 数据类型. GL_FLOAT
4. 是否标准化.
5. 步长. 其实可以理解成一个顶点属性的内存长度. 也就是数组元素的长度.
6. VBO缓冲对象中的起始位置. 是个void *类型的偏移值.

最后通过 glEnableVertexAttribArray(XXX) 启用这个顶点属性.

在这里, 顶点属性 和 顶点数据 是同一概念的.

## 顶点数组对象

渲染循环中, 为了绘制物体需要重复设置顶点属性, 当数据庞大时, 这很麻烦. 顶点数组对象(Vertex Array Object, VAO) 为了解决这个问题而生.

VAO被绑定后, 随后的顶点属性调用 glVertexAttribPointer/glEnableVertexAttribArray/glDisableVertexAttribArray 会保存在这个VAO中. 在需要绘制物体之前, 再绑定一次VAO即可.

## 着色器

常用的着色器是顶点着色器和片段着色器.

- 顶点着色器: 将3D坐标转化为另外的3D坐标.
- 片段着色器: 修改像素的颜色.

它们的流程都围绕这几个步骤:

1. GLSL语言编写着色器源码. 这个逻辑保存再C字符串中.
2. 创建着色器对象, 拿到对象标识符.                  glCreateShader
3. 将着色器源码输入到着色器对象上, 并进行编译.       glShaderSource + glCompileShader (这个编译可以理解成文本解析)
4. 创建着色器程序, 拿到对象标识符                   glCreateProgram
5. 把着色器对象附加到着色器程序上.                  glAttachShader
6. 链接. 这时候着色器程序就准备好了.                glLinkProgram + glDeleteShader (着色器对象之后都用不到了)
7. 在绘制物体(绑定VAO)之前, '掏'出着色器程序.       glUseProgram

这个过程有点像组装枪支.

- 着色器源码 == 子弹
- 着色器对象 == 弹夹
- 着色器程序 == 枪

也许这个'枪'是个'喷枪' :)

