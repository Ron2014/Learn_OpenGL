## 概念

实例化 Instancing

如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令GPU去渲染却未必。

实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -> GPU的通信。这些渲染函数的实例化版本需要一个额外的参数，叫做实例数量(Instance Count)，它能够设置我们需要渲染的实例个数。

这样我们只需要将必须的数据**发送到GPU一次**，然后使用**一次函数调用**告诉GPU它应该如何绘制这些实例。GPU将会**直接渲染**这些实例，而不用不断地与CPU进行通信。

```c
glDrawArraysInstanced(..., count, ...)
glDrawElementsInstanced(..., count, ...)
```

函数本身并没有什么用。渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置, 我们只能看见一个物体. 所以, GLSL在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。

gl_InstanceID会从0开始，在每个实例被渲染时递增1. 

**这个功能可以用于粒子系统提高性能**

## 实例化数组 

虽然之前的实现在目前的情况下能够正常工作，但是如果我们要渲染远超过100个实例的时候（这其实非常普遍），我们最终会超过最大能够发送至着色器的uniform数据大小上限。

实例化数组(Instanced Array)，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新.

我们不再使用gl_InstanceID，现在不需要索引一个uniform数组就能够直接使用offset属性了。

glVertexAttribDivisor(attrbId, divisor)

1. attrbId 顶点属性ID
2. divisor 属性除数(Attribute Divisor), 表示属性偏移更新频率
   - 0 每帧循环内没有偏移更新, 而在帧循环结束后更新属性偏移
   - 1 每帧中渲染一次新实例时, 更新属性偏移
   - 2 每帧中渲染两次新实例时, 更新属性偏移
   - ...

参数设置为 2 1, 表示: ID为2的顶点属性是个实例化数组, 每次渲染1个实例时, 数组下标更新到下一个entry.

## 小行星带 An asteroid field

**当我们顶点属性的类型大于vec4时，就要多进行一步处理了。**顶点属性最大允许的数据大小等于一个vec4。因为一个mat4本质上是4个vec4，我们需要为这个矩阵预留4个顶点属性。因为我们将它的位置值设置为3，矩阵每一列的顶点属性位置值就是3、4、5和6。

恶心, 为什么不支持呢, 其实很好实现的啊.

