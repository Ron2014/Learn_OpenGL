## 概念

阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的弱点和不足，这点我们必须要考虑到。

视频游戏中较多使用的一种技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现。阴影贴图并不难以理解，性能也不会太低，而且非常容易扩展成更高级的算法（比如 Omnidirectional Shadow Maps和 Cascaded Shadow Maps）。

## 阴影贴图/映射 shadow mapping

回想深度缓冲, 利用相机的投影矩阵, 得到片段的深度值.

如果我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中会怎样？通过这种方式，我们就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片段了。我们管储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。

当渲染P片段时, 将其与光源位置建立射线, 利用光源的的投影矩阵, 计算出这个射线的(可见深度), 如果小于两点距离, 就表示在阴影中.

阴影映射由两个步骤组成：

1. 我们渲染深度贴图
2. 我们像往常一样渲染场景，使用生成的深度贴图来计算片段是否在阴影之中

## 深度贴图 Depth Map

初始化

1. 创建2D纹理, 指定分辨率
2. 纹理源格式/目标格式为 GL_DEPTH_COMPONENT
3. 不需要颜色缓冲

渲染

1. 取得定向光的观察矩阵view和投影矩阵projection(正交/透视)
2. 使用指定渲染深度贴图的shader, 绘制场景中的物体
3. 顶点着色器中, 将所有顶点的坐标变换到定向光的观察空间
4. 片段着色器留空, 因为没有指定颜色FragColor, 会得到和深度对应的灰度图.

```c
GLfloat near_plane = 1.0f, far_plane = 7.5f;
glm::mat4 lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, near_plane, far_plane);
glm::mat4 lightView = glm::lookAt(glm::vec(-2.0f, 4.0f, -1.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f)); // 方向 2.0, -4.0, 1.0
glm::mat4 lightSpaceMatrix = lightProjection * lightView;
```

